<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="referrer" content="no-referrer">
    <meta name="robots" content="noindex,nofollow">
    <title>ibonarium planet radar</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        html,body {
            height:100%; width:100%;
            background:#000;
            color:#00ff88;
            font-family:"Courier New",monospace;
            overflow:hidden;
            touch-action:pan-x pan-y;
        }
        canvas#stars { position:fixed; inset:0; z-index:0; }
        .wrapper {
            position:relative; z-index:2;
            height:100%; padding:12px;
            display:flex; flex-direction:column; gap:16px;
            align-items:center;
        }
        h1 {
            font-size:14px; letter-spacing:2.5px; opacity:0.75;
            text-shadow:0 0 6px rgba(0,255,136,0.4);
        }
        .map-container {
            width:100%; height:55vh;
            background:#000;
            border:1px solid rgba(0,255,136,0.3);
            box-shadow:0 0 20px rgba(0,255,136,0.2);
            position:relative; overflow:hidden;
        }
        #map-canvas {
            width:100%; height:100%;
            object-fit:contain; /* вся карта ціла, без обрізки */
            image-rendering:pixelated;
        }
        .controls {
            display:flex; gap:8px; flex-wrap:wrap; justify-content:center;
        }
        button {
            background:rgba(0,40,60,0.8); 
            border:1px solid rgba(0,255,136,0.4);
            color:#00ff88; padding:6px 12px;
            font-size:11px; letter-spacing:1.2px;
            cursor:pointer; transition:.3s;
            min-width:70px;
        }
        button:hover, button:active {
            background:rgba(0,255,136,0.15);
            box-shadow:0 0 12px rgba(0,255,136,0.5);
        }
        button.active {
            background:rgba(0,255,136,0.25);
            box-shadow:0 0 15px rgba(0,255,136,0.6);
            color:#000;
        }
        .status {
            font-size:11px; letter-spacing:1.8px; opacity:0.6;
        }
        .city-markers {
            position:absolute; top:6px; left:6px; z-index:10;
            display:flex; flex-direction:column; gap:6px;
        }
        .city {
            background:rgba(0,0,0,0.7); padding:3px 6px;
            border:1px solid rgba(0,255,136,0.4);
            font-size:10px; letter-spacing:1px;
            box-shadow:0 0 8px rgba(0,255,136,0.3);
            white-space:nowrap;
        }
        /* Оптимізація для девайсів */
        @media (max-width: 480px) {
            .wrapper { padding:8px; gap:12px; }
            h1 { font-size:13px; }
            .map-container { height:50vh; }
            .controls { gap:6px; }
            button { padding:5px 10px; font-size:10px; min-width:60px; }
            .status { font-size:10px; }
            .city { font-size:9px; padding:2px 5px; }
        }
        @media (max-height: 600px) {
            .map-container { height:45vh; }
        }
        @media (orientation: landscape) {
            .map-container { height:65vh; }
        }
    </style>
</head>
<body>
<canvas id="stars"></canvas>
<div class="wrapper">
    <h1>IBONARIUM PLANET RADAR</h1>
    
    <div class="map-container">
        <canvas id="map-canvas"></canvas>
        <div class="city-markers" id="city-markers"></div>
    </div>
    
    <div class="controls">
        <button data-layer="clouds_new" class="active">CLOUDS</button>
        <button data-layer="temp_new">TEMP</button>
        <button data-layer="precipitation_new">PRECIP</button>
        <button data-layer="wind_new">WIND</button>
        <button data-layer="pressure_new">PRESSURE</button>
        <button data-layer="relief">RELIEF</button>
    </div>
    
    <p class="status" id="status">SCANNING...</p>
</div>

<script>
    /* STARFIELD — оптимізований */
    const starsC = document.getElementById("stars");
    const starsCtx = starsC.getContext("2d");
    let SW, SH, stars = [];
    function resizeStars() {
        SW = starsC.width = innerWidth;
        SH = starsC.height = innerHeight;
        const count = SW < 768 ? 60 : 120;
        stars = Array.from({length: count}, () => ({
            x: Math.random() * SW, y: Math.random() * SH, z: Math.random() * SW
        }));
    }
    resizeStars();
    window.addEventListener("resize", resizeStars);
    function drawStars() {
        starsCtx.fillStyle = "rgba(0,0,0,0.08)";
        starsCtx.fillRect(0, 0, SW, SH);
        starsCtx.fillStyle = "#00ff88";
        stars.forEach(st => {
            st.z -= 0.06;
            if (st.z <= 0) st.z = SW;
            const k = 100 / st.z;
            const x = (st.x - SW / 2) * k + SW / 2;
            const y = (st.y - SH / 2) * k + SH / 2;
            if (x > 0 && x < SW && y > 0 && y < SH) {
                const size = (1 - st.z / SW) * 1.2;
                starsCtx.globalAlpha = 1 - st.z / SW;
                starsCtx.fillRect(x, y, size, size);
            }
        });
        starsCtx.globalAlpha = 1;
        requestAnimationFrame(drawStars);
    }
    drawStars();

    /* MAP RADAR — швидкий, без масштабування, вся карта ціла */
    const API_KEY = "b99fdb51e2dcc8e0549f8b99ef20cedd";
    const ZOOM = 2;
    const TILE_SIZE = 256;
    const canvas = document.getElementById("map-canvas");
    const ctx = canvas.getContext("2d");
    let currentLayer = "clouds_new";
    let baseTiles = {};
    let layerTiles = {};
    let lastUpdate = 0;
    const UPDATE_INTERVAL = 15 * 60 * 1000;

    const BASE_URL = "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}";

    const cities = [
        {name: "KYIV", lat: 50.45, lon: 30.52},
        {name: "TOKYO", lat: 35.68, lon: 139.76},
        {name: "NIGHT CITY", lat: 37.77, lon: -122.42},
        {name: "MOSCOW", lat: 55.75, lon: 37.62},
        {name: "BERLIN", lat: 52.52, lon: 13.40}
    ];

    function resizeMap() {
        const container = canvas.parentElement;
        canvas.width = container.offsetWidth * devicePixelRatio;
        canvas.height = container.offsetHeight * devicePixelRatio;
        ctx.scale(devicePixelRatio, devicePixelRatio);
        renderMap();
        renderCityMarkers();
    }
    window.addEventListener("resize", resizeMap);

    async function fetchBaseTile(x, y) {
        const key = `${x}_${y}`;
        if (baseTiles[key]) return baseTiles[key];
        const url = BASE_URL.replace('{z}', ZOOM).replace('{x}', x).replace('{y}', y);
        const img = new Image();
        img.crossOrigin = "anonymous";
        return new Promise(resolve => {
            img.onload = () => { baseTiles[key] = img; resolve(img); };
            img.onerror = () => resolve(null);
            img.src = url;
        });
    }

    async function fetchLayerTile(x, y) {
        const key = `${currentLayer}_${x}_${y}`;
        if (layerTiles[key]) return layerTiles[key];
        let url = `https://tile.openweathermap.org/map/${currentLayer}/${ZOOM}/${x}/${y}.png?appid=${API_KEY}`;
        if (currentLayer === "relief") url = `https://tile.openweathermap.org/map/relief/${ZOOM}/${x}/${y}.png?appid=${API_KEY}`;
        const img = new Image();
        img.crossOrigin = "anonymous";
        return new Promise(resolve => {
            img.onload = () => { layerTiles[key] = img; resolve(img); };
            img.onerror = () => resolve(null);
            img.src = url;
        });
    }

    async function loadMap() {
        const statusEl = document.getElementById("status");
        statusEl.textContent = "SCANNING...";
        const tilesCount = 1 << ZOOM;
        const promises = [];
        for (let x = 0; x < tilesCount; x++) {
            for (let y = 0; y < tilesCount; y++) {
                promises.push(fetchBaseTile(x, y));
                promises.push(fetchLayerTile(x, y));
            }
        }
        await Promise.allSettled(promises); // швидше, бо не чекає помилок
        renderMap();
        renderCityMarkers();
        statusEl.textContent = `RADAR: ${currentLayer.replace('_new','').toUpperCase()}`;
        lastUpdate = Date.now();
    }

    function latLonToPixel(lat, lon) {
        const tilesCount = 1 << ZOOM;
        const x = (lon + 180) / 360 * tilesCount * TILE_SIZE;
        const y = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * tilesCount * TILE_SIZE;
        const container = canvas.parentElement;
        return {
            x: (x / (tilesCount * TILE_SIZE)) * container.offsetWidth,
            y: (y / (tilesCount * TILE_SIZE)) * container.offsetHeight
        };
    }

    async function fetchCityWeather(city) {
        try {
            const res = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${city.lat}&lon=${city.lon}&appid=${API_KEY}&units=metric`);
            const data = await res.json();
            return `${city.name}: ${Math.round(data.main.temp)}°C`;
        } catch {
            return `${city.name}: —`;
        }
    }

    async function renderCityMarkers() {
        const container = document.getElementById("city-markers");
        container.innerHTML = "";
        for (const city of cities) {
            const text = await fetchCityWeather(city);
            const div = document.createElement("div");
            div.className = "city";
            div.textContent = text;
            container.appendChild(div);
        }
    }

    function renderMap() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const tilesCount = 1 << ZOOM;
        const containerW = canvas.parentElement.offsetWidth;
        const containerH = canvas.parentElement.offsetHeight;
        const tileSizeW = containerW / tilesCount;
        const tileSizeH = containerH / tilesCount;

        for (let x = 0; x < tilesCount; x++) {
            for (let y = 0; y < tilesCount; y++) {
                const bx = x * tileSizeW;
                const by = y * tileSizeH;

                const base = baseTiles[`${x}_${y}`];
                if (base) ctx.drawImage(base, bx, by, tileSizeW, tileSizeH);

                const layer = layerTiles[`${currentLayer}_${x}_${y}`];
                if (layer) ctx.drawImage(layer, bx, by, tileSizeW, tileSizeH);
            }
        }

        // Легкий сканлайн (тільки на десктопах)
        if (innerWidth > 768) {
            const time = Date.now() * 0.001;
            ctx.fillStyle = `rgba(0,255,136,${0.04 + 0.02 * Math.sin(time * 3)})`;
            ctx.fillRect(0, containerH * ((time * 0.4) % 1), containerW, 2);
        }
    }

    document.querySelectorAll('button[data-layer]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.dataset.layer === currentLayer) return;
            document.querySelector('.active')?.classList.remove('active');
            btn.classList.add('active');
            currentLayer = btn.dataset.layer;
            layerTiles = {};
            await loadMap();
        });
    });

    async function autoUpdate() {
        if (Date.now() - lastUpdate > UPDATE_INTERVAL) {
            layerTiles = {};
            await loadMap();
        }
        renderMap();
        requestAnimationFrame(autoUpdate);
    }

    resizeMap();
    loadMap();
    autoUpdate();
</script>
</body>
</html>
